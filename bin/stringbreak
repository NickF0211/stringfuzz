#!/usr/bin/env python3

import sys
import argparse

from stringfuzz.constants import LANGUAGES, SMT_20_STRING, SMT_25_STRING
from stringfuzz.generators import random_ast
from stringfuzz.generator import generate
from stringfuzz.parser import parse
from stringfuzz.smt import smt_string_logic

from stringfuzz.fuzzers.genetic import simulate

# constants
DEFAULT_NUM_GENERATIONS = 200
DEFAULT_WORLD_SIZE      = 10

DEFAULT_TRACE_RESOLUTION = 1
TRACE_BY_DEFAULT         = False

# globals
_tracing_on = False

# helpers
def trace(*args, **kwargs):
    global _tracing_on
    if _tracing_on is True:
        print(*args, file=sys.stderr, **kwargs)

# main
def main():

    # create arg parser
    parser = argparse.ArgumentParser(description='Test an SMT string solver in an exploratory fashion.')
    parser.add_argument(
        'command',
        type = str,
        help = 'command to run the solver (if input fed on standard in)'
    )

    # I/O arguments
    parser.add_argument(
        '--out-language',
        '-o',
        dest    = 'out_language',
        type    = str,
        choices = LANGUAGES,
        default = SMT_25_STRING,
        help    = 'solver language (default: {})'.format(SMT_25_STRING)
    )
    parser.add_argument(
        '--in-language',
        '-i',
        dest    = 'in_language',
        type    = str,
        choices = LANGUAGES,
        default = SMT_25_STRING,
        help    = 'seed problem language (default: {})'.format(SMT_25_STRING)
    )
    parser.add_argument(
        '--trace',
        '-t',
        dest    = 'trace',
        action  = 'store_true',
        default = TRACE_BY_DEFAULT,
        help    = 'print status messages (default: {})'.format(TRACE_BY_DEFAULT)
    )
    parser.add_argument(
        '--seed-problem',
        '-s',
        dest    = 'seed_problem',
        metavar = 'F',
        default = None,
        type    = argparse.FileType('r'),
        help    = 'input file (default: stdin)'
    )

    # simulation arguments
    parser.add_argument(
        '--num-generations',
        '-g',
        dest    = 'num_generations',
        metavar = 'N',
        type    = int,
        default = DEFAULT_NUM_GENERATIONS,
        help    = 'number of generations to simulate (default: {})'.format(DEFAULT_NUM_GENERATIONS)
    )
    parser.add_argument(
        '--world-size',
        '-w',
        dest    = 'world_size',
        metavar = 'N',
        type    = int,
        default = DEFAULT_WORLD_SIZE,
        help    = 'number of organisms in the world (default: {})'.format(DEFAULT_WORLD_SIZE)
    )

    # parse args
    args = parser.parse_args()

    # set tracing mode
    global _tracing_on
    _tracing_on = args.trace

    # use passed seed problem
    if args.seed_problem is not None:
        seed_problem = parse(args.seed_problem.read(), args.in_language)

    # or create a random one
    else:
        seed_problem = [smt_string_logic()] + random_ast(
            num_vars            = 1,
            num_asserts         = 5,
            depth               = 3,
            max_terms           = 5,
            max_str_lit_length  = 10,
            max_int_lit         = 30,
            literal_probability = 0.5,
            semantically_valid  = True
        )

    # print seed problem
    trace('progenitor:')
    trace('-----')
    trace(generate(seed_problem, args.out_language))
    trace('-----')

    # run the tester
    trace('')
    trace('simulating ...')
    surviving_problems = simulate(
        progenitor       = seed_problem,
        language         = args.out_language,
        solver_command   = args.command,
        num_generations  = args.num_generations,
        world_size       = args.world_size,
        trace_resolution = DEFAULT_TRACE_RESOLUTION,
        enable_tracing   = _tracing_on
    )
    trace('finished')
    trace('')

    # print out final population
    for i, problem in enumerate(surviving_problems):
        print('survivor #{}'.format(i + 1))
        print('-----')
        print(generate(problem, args.out_language))
        print('-----')

if __name__ == '__main__':
    main()
